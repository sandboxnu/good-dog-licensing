// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_PRISMA_URL")
}

enum Role {
  MUSICIAN
  MEDIA_MAKER
  ADMIN
  MODERATOR
}

enum MatchState {
  NEW
  SONG_REQUESTED
  REJECTED_BY_MEDIA_MAKER
  REJECTED_BY_MUSICIAN
  APPROVED_BY_MUSICIAN
}

model User {
  userId             String              @id @default(uuid()) @map("id")
  email              String              @unique
  phoneNumber        String
  hashedPassword     String              @map("password")
  firstName          String
  lastName           String
  role               Role
  affiliation        MusicAffiliation?
  ipi                String?
  passwordResetReq   PasswordResetReq?
  sessions           Session[]
  referral           ReferralSource?
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  projectSubmissions ProjectSubmission[]
  musicSubmissions   MusicSubmission[]
  matches            Match[]             @relation("Matcher")
  comments           Comments[]
}

enum ReferralSource {
  FRIEND
  COLLEAGUE
  GREEN_LINE_RECORDS
  SOCIAL_MEDIA
  OTHER
}

model Session {
  sessionId String   @id @default(uuid()) @map("id")
  userId    String
  createdAt DateTime @default(now())
  expiresAt DateTime
  user      User     @relation(fields: [userId], references: [userId], onDelete: Cascade)
}

model EmailVerificationCode {
  email     String   @id
  code      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  expiresAt DateTime
}

model PasswordResetReq {
  passwordResetId String   @id @default(cuid())
  user            User     @relation(fields: [passwordResetId], references: [userId], onDelete: Cascade)
  createdAt       DateTime @default(now())
  expiresAt       DateTime
}

model ModeratorInvite {
  moderatorInviteId String   @id @default(cuid())
  email             String   @unique
  createdAt         DateTime @default(now())
  expiresAt         DateTime
}

model ProjectSubmission {
  projectId      String        @id @default(uuid())
  projectOwnerId String
  projectOwner   User          @relation(fields: [projectOwnerId], references: [userId], onDelete: Cascade)
  projectTitle   String
  description    String
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  songRequests   SongRequest[]
  deadline       DateTime
  videoLink      String        @default("")
  additionalInfo String        @default("")
}

model SongRequest {
  songRequestId     String            @id @default(uuid())
  oneLineSummary    String
  description       String
  musicType         String
  similarSongs      String            @default("")
  additionalInfo    String            @default("")
  projectId         String
  projectSubmission ProjectSubmission @relation(fields: [projectId], references: [projectId], onDelete: Cascade)
  matches           Match[]
  comments          Comments[]
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
}

model MusicSubmission {
  musicId        String             @id @default(uuid())
  songName       String
  performerName  String
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt
  submitter      User               @relation(fields: [submitterId], references: [userId], onDelete: Cascade)
  submitterId    String
  songLink       String
  genre          String
  additionalInfo String             @default("")
  matches        Match[]
  contributors   MusicContributor[]
}

enum MusicRole {
  VOCALIST
  INSTRUMENTALIST
  PRODUCER
  SONGWRITER
  LYRICIST
}

enum MusicAffiliation {
  ASCAP
  BMI
  NONE
}

model MusicContributor {
  contributorId          String           @id @default(uuid())
  name                   String
  roles                  MusicRole[]
  affiliation            MusicAffiliation
  ipi                    String?
  MusicSubmission        MusicSubmission  @relation(fields: [musicSubmissionMusicId], references: [musicId], onDelete: Cascade)
  musicSubmissionMusicId String
}


model Match {
  matchId         String          @id @default(uuid())
  songRequestId   String
  songRequest     SongRequest     @relation(fields: [songRequestId], references: [songRequestId], onDelete: Cascade)
  musicId         String
  musicSubmission MusicSubmission @relation(fields: [musicId], references: [musicId], onDelete: Cascade)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  matcherUserId   String
  matcherUser     User            @relation("Matcher", fields: [matcherUserId], references: [userId], onDelete: NoAction)
  matchState      MatchState

  @@unique([songRequestId, musicId])
  @@map("Matches")
}

model Comments {
  commentId     String       @id @default(uuid())
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  commentText   String
  userId        String
  user          User         @relation(fields: [userId], references: [userId], onDelete: NoAction)
  songRequestId String?
  songRequest   SongRequest? @relation(fields: [songRequestId], references: [songRequestId], onDelete: Cascade)
}
