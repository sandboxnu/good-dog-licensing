// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_PRISMA_URL")
}

enum Role {
  MUSICIAN
  MEDIA_MAKER
  ADMIN
  MODERATOR
}

enum MatchState {
  WAITING_FOR_MANAGER_APPROVAL
  NEW
  SONG_REQUESTED
  REJECTED_BY_MEDIA_MAKER
  REJECTED_BY_MUSICIAN
  APPROVED_BY_MUSICIAN
}

model User {
  userId                      String              @id @default(uuid()) @map("id")
  email                       String              @unique
  phoneNumber                 String
  hashedPassword              String              @map("password")
  firstName                   String
  lastName                    String
  role                        Role
  affiliation                 MusicAffiliation?
  ipi                         String?
  passwordResetReq            PasswordResetReq?
  sessions                    Session[]
  createdAt                   DateTime            @default(now())
  updatedAt                   DateTime            @updatedAt
  projectSubmissionsAsOwner   ProjectSubmission[] @relation("ProjectOwner")
  projectSubmissionsAsManager ProjectSubmission[] @relation("ProjectManager")
  musicSubmissions            MusicSubmission[]
  matches                     Match[]             @relation("Matcher")
  comments                    Comments[]
}

model Session {
  sessionId String   @id @default(uuid()) @map("id")
  userId    String
  createdAt DateTime @default(now())
  expiresAt DateTime
  user      User     @relation(fields: [userId], references: [userId], onDelete: Cascade)
}

model EmailVerificationCode {
  email     String   @id
  code      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  expiresAt DateTime
}

model PasswordResetReq {
  passwordResetId String   @id @default(cuid())
  user            User     @relation(fields: [passwordResetId], references: [userId], onDelete: Cascade)
  createdAt       DateTime @default(now())
  expiresAt       DateTime
}

model ModeratorInvite {
  moderatorInviteId String   @id @default(cuid())
  email             String   @unique
  createdAt         DateTime @default(now())
  expiresAt         DateTime
}

model ProjectSubmission {
  projectId         String        @id @default(uuid())
  projectOwnerId    String
  projectOwner      User          @relation("ProjectOwner", fields: [projectOwnerId], references: [userId], onDelete: Cascade)
  projectManagerId  String?
  projectManager    User?         @relation("ProjectManager", fields: [projectManagerId], references: [userId], onDelete: Cascade)
  projectTitle      String
  description       String
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  songRequests      SongRequest[]
  deadline          DateTime
  videoLink         String        @default("")
  additionalInfo    String        @default("")
  projectType       ProjectType
}

model SongRequest {
  songRequestId     String            @id @default(uuid())
  songRequestTitle  String
  description       String
  feelingsConveyed  String
  similarSongs      String
  additionalInfo    String            @default("")
  projectId         String
  projectSubmission ProjectSubmission @relation(fields: [projectId], references: [projectId], onDelete: Cascade)
  matches           Match[]
  comments          Comments[]
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
}

enum ProjectType {
  MOTION_PICTURE
  SOCIAL_MEDIA_REEL
  VIDEO_GAME
}

model MusicSubmission {
  musicId        String             @id @default(uuid())
  songName       String
  performerName  String
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt
  submitter      User               @relation(fields: [submitterId], references: [userId], onDelete: Cascade)
  submitterId    String
  songLink       String
  genres         Genre[]
  additionalInfo String             @default("")
  matches        Match[]
  contributors   MusicContributor[]
}

enum Genre {
  ROCK
  POP
  HIP_HOP
  JAZZ
  CLASSICAL
  ELECTRONIC
  COUNTRY
  REGGAE
  BLUES
  FOLK
  OTHER
}

enum MusicRole {
  VOCALIST
  INSTRUMENTALIST
  PRODUCER
  SONGWRITER
  LYRICIST
}

enum MusicAffiliation {
  ASCAP
  BMI
  NONE
}

model MusicContributor {
  contributorId     String            @id @default(uuid())
  firstName         String
  lastName          String
  roles             MusicRole[]
  affiliation       MusicAffiliation?
  ipi               String?
  MusicSubmission   MusicSubmission   @relation(fields: [musicSubmissionId], references: [musicId], onDelete: Cascade)
  musicSubmissionId String
  isSubmitter       Boolean           @default(false)
}

model Match {
  matchId         String          @id @default(uuid())
  songRequestId   String
  songRequest     SongRequest     @relation(fields: [songRequestId], references: [songRequestId], onDelete: Cascade)
  musicId         String
  musicSubmission MusicSubmission @relation(fields: [musicId], references: [musicId], onDelete: Cascade)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  matcherUserId   String
  matcherUser     User            @relation("Matcher", fields: [matcherUserId], references: [userId], onDelete: NoAction)
  matchState      MatchState

  @@unique([songRequestId, musicId])
  @@map("Matches")
}

model Comments {
  commentId     String       @id @default(uuid())
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  commentText   String
  userId        String
  user          User         @relation(fields: [userId], references: [userId], onDelete: NoAction)
  songRequestId String?
  songRequest   SongRequest? @relation(fields: [songRequestId], references: [songRequestId], onDelete: Cascade)
}
