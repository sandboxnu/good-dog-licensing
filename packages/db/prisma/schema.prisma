// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_PRISMA_URL")
}

enum Role {
  MUSICIAN
  MEDIA_MAKER
  ADMIN
  MODERATOR
}

enum MatchState {
  APPROVED
  REJECTED
  PENDING
}

model User {
  userId             String              @id @default(uuid()) @map("id")
  email              String              @unique
  phoneNumber        String
  hashedPassword     String              @map("password")
  firstName          String
  lastName           String
  role               Role
  affiliation        MusicAffiliation?
  ipi                String?
  passwordResetReq   PasswordResetReq?
  sessions           Session[]
  referral           ReferralSource?
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  projectSubmissions ProjectSubmission[]
  musicSubmissions   MusicSubmission[]
  suggestedMatches   SuggestedMatch[]    @relation("Matcher")
  reviewedMatches    SuggestedMatch[]    @relation("Reviewer")
  matchComments      MatchComments[]
  matchLikes         MatchRatings[]
}

enum ReferralSource {
  FRIEND
  COLLEAGUE
  GREEN_LINE_RECORDS
  SOCIAL_MEDIA
  OTHER
}

model Session {
  sessionId String   @id @default(uuid()) @map("id")
  userId    String
  createdAt DateTime @default(now())
  expiresAt DateTime
  user      User     @relation(fields: [userId], references: [userId], onDelete: Cascade)
}

model EmailVerificationCode {
  email     String   @id
  code      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  expiresAt DateTime
}

model PasswordResetReq {
  passwordResetId String   @id @default(cuid())
  user            User     @relation(fields: [passwordResetId], references: [userId], onDelete: Cascade)
  createdAt       DateTime @default(now())
  expiresAt       DateTime
}

model ModeratorInvite {
  moderatorInviteId String   @id @default(cuid())
  email             String   @unique
  createdAt         DateTime @default(now())
  expiresAt         DateTime
}

model ProjectSubmission {
  projectId        String                @id @default(uuid())
  projectOwnerId   String
  projectOwner     User                  @relation(fields: [projectOwnerId], references: [userId], onDelete: Cascade)
  projectTitle     String
  description      String
  createdAt        DateTime              @default(now())
  updatedAt        DateTime              @updatedAt
  songRequests     SongRequest[]
  deadline         DateTime
  videoLink        String                @default("")
  additionalInfo   String                @default("")
  suggestedMatches SuggestedMatch[]
}

model SongRequest {
  songRequestId           String            @id @default(uuid())
  oneLineSummary          String 
  description             String
  musicType               String
  similarSongs            String            @default("")
  additionalInfo          String            @default("")
  projectId               String
  projectSubmission       ProjectSubmission @relation(fields: [projectId], references: [projectId], onDelete: Cascade)
  suggestedMatches        SuggestedMatch[]
  createdAt               DateTime          @default(now())
  updatedAt               DateTime          @updatedAt
}

model MusicSubmission {
  musicId          String             @id @default(uuid())
  songName         String
  performerName    String
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  submitter        User               @relation(fields: [submitterId], references: [userId], onDelete: Cascade)
  submitterId      String
  songLink         String
  genre            String
  additionalInfo   String             @default("")
  suggestedMatches SuggestedMatch[]
  contributors     MusicContributor[]
}

enum MusicRole {
  VOCALIST
  INSTRUMENTALIST
  PRODUCER
  SONGWRITER
  LYRICIST
}

enum MusicAffiliation {
  ASCAP
  BMI
  NONE
}

model MusicContributor {
  contributorId          String           @id @default(uuid())
  name                   String
  roles                  MusicRole[]
  affiliation            MusicAffiliation
  ipi                    String?
  MusicSubmission        MusicSubmission  @relation(fields: [musicSubmissionMusicId], references: [musicId], onDelete: Cascade)
  musicSubmissionMusicId String
}

model SuggestedMatch {
  suggestedMatchId  String            @id @default(uuid())
  projectId         String
  projectSubmission ProjectSubmission @relation(fields: [projectId], references: [projectId], onDelete: NoAction)
  songRequestId     String
  songRequest       SongRequest       @relation(fields: [songRequestId], references: [songRequestId], onDelete: Cascade)
  musicId           String
  musicSubmission   MusicSubmission   @relation(fields: [musicId], references: [musicId], onDelete: Cascade)
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  description       String
  matchComments     MatchComments[]
  matchLikes        MatchRatings[]
  matcherUserId     String
  matcherUser       User              @relation("Matcher", fields: [matcherUserId], references: [userId], onDelete: NoAction)
  matchState        MatchState
  reviewerId        String?
  reviewer          User?             @relation("Reviewer", fields: [reviewerId], references: [userId], onDelete: NoAction)

  @@unique([songRequestId, musicId])
  @@map("SuggestedMatches")
}

model MatchComments {
  commentId        String          @id @default(uuid())
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  commentText      String
  userId           String
  user             User            @relation(fields: [userId], references: [userId], onDelete: NoAction)
  suggestedMatchId String?
  suggestedMatch   SuggestedMatch? @relation(fields: [suggestedMatchId], references: [suggestedMatchId], onDelete: NoAction)
}

model MatchRatings {
  ratingId         String          @id @default(uuid())
  userId           String
  user             User            @relation(fields: [userId], references: [userId], onDelete: NoAction)
  ratingEnum       Rating
  suggestedMatchId String?
  suggestedMatch   SuggestedMatch? @relation(fields: [suggestedMatchId], references: [suggestedMatchId], onDelete: NoAction)
}

enum Rating {
  LIKE
  DISLIKE
}
